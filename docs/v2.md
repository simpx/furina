# packice v2 Design & Implementation

## Objective
Refine the packice architecture to achieve better abstraction and decoupling. The goal is to separate the core logic (Peer, Lease, Object) from the implementation details (Storage, Transport), enabling flexible composition of nodes (e.g., HTTP+FS, UDS+Memfd) and easier future extensions (e.g., Redis-based Lease, S3-based Blob).

## Core Abstractions (Core Layer)

### 1. Blob (`core/blob.py`)
Represents a contiguous chunk of data. It abstracts away *where* the data is stored and *how* it is accessed.
- **Interface**: `read()`, `write()`, `seal()`, `get_handle()`.
- **Handle**: An opaque identifier used by the transport layer to give clients access. It could be a file path (string) or a file descriptor (int).

### 2. Object (`core/object.py`)
The unit of management in packice.
- Contains a list of `Blob`s and metadata.
- Manages state: `CREATING` -> `SEALED`.
- **Decoupling**: The Object holds the Blobs, but doesn't know about Leases.

### 3. Lease (`core/lease.py`)
Represents the right to access an Object.
- **Decoupling**: Lease holds `object_id` (string) instead of a direct reference to `Object`. This allows Lease and Object to potentially reside in different systems (e.g., Lease in Redis, Object in S3).
- **Attributes**: `lease_id`, `object_id`, `access` (READ/CREATE), `ttl`.
- **Abstract Base Class**: Defined as an ABC to support different implementations (Memory, Redis, Etcd).

### 4. Peer (`core/peer.py`)
The central coordinator (formerly Engine).
- Manages the lifecycle of Objects and Leases.
- **Dependency Injection**: Accepts `BlobFactory` and `LeaseFactory` at initialization.
- **API**: `acquire()`, `seal()`, `release()`.
- **Acquire Return**: Returns `(Lease, Object)` tuple, allowing the transport layer to decide what to return to the client (e.g., just the handles).

## Implementations (Impl Layer)

### Blob Implementations
- **FileBlob (`impl/fs_blob.py`)**: Stores data in a local file system. Handle is the file path.
- **MemBlob (`impl/mem_blob.py`)**: Stores data in memory (using `memfd_create` on Linux or `tempfile` on others). Handle is the file descriptor (FD).

### Lease Implementations
- **MemoryLease (`impl/memory_lease.py`)**: Stores lease state in Python memory. Generates UUIDs internally.

## Transport Layer (Transport Layer)

Adapts the Core Peer to specific network protocols.

### 1. HTTP Transport (`transport/http_server.py`)
- **Protocol**: JSON over HTTP.
- **Data Transfer**: Returns the file paths (handles) in the JSON response. Clients read/write via standard file I/O (assuming shared FS).
- **Use Case**: Networked nodes, shared storage.

### 2. UDS Transport (`transport/uds_server.py`)
- **Protocol**: JSON over Unix Domain Sockets.
- **Data Transfer**: Uses `SCM_RIGHTS` to pass File Descriptors (FDs) between processes. Zero-copy data access.
- **Use Case**: Local high-performance IPC, container sidecars.

## SDK (`sdk.py`)

A unified Python client library that hides the complexity of different transports.

- **Client**: 
    - Auto-detects transport type based on address (`http://...` vs `/tmp/...`).
    - Supports **In-Process** usage by accepting a `Peer` instance directly.
- **Lease**: Represents a held lease.
    - `open(mode)`: Unified interface to open the blob as a file-like object, handling both paths and FDs transparently.
    - `seal()`: Seals the object.
    - `release()`: Releases the lease and cleans up resources (closes FDs).

## Node Entrypoint (`main.py`)

Composes the system components based on configuration.
- **Arguments**: `--impl {fs,mem}`, `--transport {http,uds}`.
- **Composition**:
    - `fs` + `http`: Traditional file-server-like node.
    - `mem` + `uds`: High-speed in-memory cache node.

## Example Usage

### In-Process (Direct Usage)
```python
from packice.v2.core.peer import Peer
from packice.v2.impl.mem_blob import MemBlob
from packice.v2.impl.memory_lease import MemoryLease
from packice.v2.sdk import Client

# Setup Peer
peer = Peer(lambda oid: MemBlob(oid), lambda oid, acc, ttl: MemoryLease(oid, acc, ttl))

# Use SDK directly
client = Client(peer)
lease = client.acquire(intent="create")
with lease.open("wb") as f:
    f.write(b"data")
lease.seal()
lease.release()
```

### Networked Server
```bash
# Start a UDS node with Memory storage
python3 -m packice.v2.main --impl mem --transport uds --socket /tmp/packice.sock
```

### Networked Client
```python
from packice.v2.sdk import Client

# Connect to UDS node
client = Client("/tmp/packice.sock")
lease = client.acquire(intent="create")
with lease.open("wb") as f:
    f.write(b"data")
lease.seal()
lease.release()
```
